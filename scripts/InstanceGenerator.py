'''
Project AMMM
Instance Generator

Juan Francisco Martinez Vera
juan.francisco.martinez@est.fib.upc.edu
'''

import sys
import math, random
import time

NUM_CITIES=10
SPACE_DIM=0 # init
MAX_DISTANC=720
RAND_SEED=int(time.time())

NICE=False

def generatePoints(ncities, dim):
    # The coordinates sources is in the middle
    # of the plane.

    random.seed(RAND_SEED)
    cities=[]
    for i in range(ncities):
        posx=random.uniform(-dim/2, dim/2)
        posy=random.uniform(-dim/2, dim/2)

        cities.append([posx,posy])
    return cities

def calculeDistances(ncities, poscities):
    # Calcule cartesian distances
    distances=list()
    
    for i in range(ncities):
        dists=[]
        for j in range(ncities):
            if i==j: dists.append(0)
            else:
                d=math.sqrt((poscities[i][0]-poscities[j][0])**2 + \
                        (poscities[i][1]-poscities[j][1])**2)
                # Our model only permits INTs
                # also, we are getting the floor round value
                dists.append(int(d))
        distances.append(dists)

    return distances

def calculeTask(ncities, poscities):
    # TODO: The task should be inversely proportional
    # to the distance to the center of the plane.
    
    task=[]
    for i in range(ncities):
        if NICE:
            dist_to_center=math.sqrt(poscities[i][0]**2 + \
                                 poscities[i][1]**2)
            # We know that the maximum distance is MAX_DISTANC/ncities
            time=random.randrange(int(MAX_DISTANC/ncities)-int(dist_to_center))
        else:
            time=random.randrange(1,MAX_DISTANC)
        task.append(time)
        
    return task

def calculeWindows(ncities):
    # TODO: To model

    minW=[]
    maxW=[]
    for i in range(ncities):
        if not NICE:
            min_w=random.randrange(MAX_DISTANC)
            max_w=random.randrange(min_w, MAX_DISTANC)
        else:
            min_w=1
            max_w=MAX_DISTANC
        
        minW.append(min_w)
        maxW.append(max_w)
        
    return minW, maxW

def main(argc, argv):
    if argc>1:
        ncities=argv[1]
    else:
        ncities=NUM_CITIES

    # This calculus is enforcing that the maximum distance
    # between two cities in the worst case (diagonal) 
    # is at most 720/ncitis in order to ensure feasible solutions.
    SPACE_DIM=math.sqrt( (MAX_DISTANC/ncities)**2/2)
    
    ###################
    # Generating data #
    ###################
    poscities = generatePoints(ncities, SPACE_DIM)
    distances = calculeDistances(ncities, poscities)
    citytask  = calculeTask(ncities, poscities)
    minW, maxW  = calculeWindows(ncities)
    stLocation = random.randrange(1,ncities)
    
    citytask[stLocation-1]=0
    
    #import pdb; pdb.set_trace()

    ####################
    # Writting results #
    ####################
    outfile=open("./Instances/instance_{0}_{1}.dat".format(ncities, RAND_SEED), "w")
    
    import pprint
    pp = pprint.PrettyPrinter(indent=4, depth=200, stream=outfile)
        
    outfile.write("// Generated by InstanceGenerator.py v0.1\n")
    outfile.write("// Juan Francisco Martinez Vera\n")
    outfile.write("// AMMM - MIRI, FIB UPC\n")
    outfile.write("//\n// RAND_SEED={0}\n\n".format(RAND_SEED))
    
    outfile.write("bigM=100000;\n\n")
    outfile.write("nLocations={0};\n".format(ncities))
    outfile.write("startLocation={0};\n".format(stLocation))
    outfile.write("distances=")
    pp.pprint(distances)
    outfile.write(";\ntask=")
    pp.pprint(citytask)
    outfile.write(";\nminW=")
    pp.pprint(minW)
    outfile.write(";\nmaxW=")
    pp.pprint(maxW)
    outfile.write(";")

if __name__=="__main__":
	main(len(sys.argv), sys.argv)
